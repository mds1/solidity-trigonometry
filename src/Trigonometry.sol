/**
 * Basic trigonometry functions
 *
 * Solidity library offering the functionality of basic trigonometry functions
 * with both input and output being integer approximated.
 *
 * This is useful since:
 * - At the moment no floating/fixed point math can happen in solidity
 * - Should be (?) cheaper than the actual operations using floating point
 *   if and when they are implemented.
 *
 * The implementation is based off Dave Dribin's trigint C library
 * http://www.dribin.org/dave/trigint/
 * Which in turn is based from a now deleted article which can be found in
 * the internet wayback machine:
 * http://web.archive.org/web/20120301144605/http://www.dattalo.com/technical/software/pic/picsine.html
 *
 * @author Lefteris Karapetsas
 * @license BSD3
 */

pragma solidity ^0.8.7;

library Trigonometry {
  // Table index into the trigonometric table
  uint256 constant INDEX_WIDTH = 4;
  // Interpolation between successive entries in the tables
  uint256 constant INTERP_WIDTH = 8;
  uint256 constant INDEX_OFFSET = 12 - INDEX_WIDTH;
  uint256 constant INTERP_OFFSET = INDEX_OFFSET - INTERP_WIDTH;
  uint16 constant ANGLES_IN_CYCLE = 16384;
  uint16 constant QUADRANT_HIGH_MASK = 8192;
  uint16 constant QUADRANT_LOW_MASK = 4096;
  uint256 constant SINE_TABLE_SIZE = 16;

  // constant sine lookup table generated by gen_tables.py
  // We have no other choice but this since constant arrays don't yet exist
  uint8 constant entry_bytes = 2;
  bytes constant sin_table =
    hex"00_00_0c_8c_18_f9_25_28_30_fb_3c_56_47_1c_51_33_5a_82_62_f1_6a_6d_70_e2_76_41_7a_7c_7d_89_7f_61_7f_ff";

  /**
   * Convenience function to apply a mask on an integer to extract a certain
   * number of bits. Using exponents since solidity still does not support
   * shifting.
   *
   * @param _value The integer whose bits we want to get
   * @param _width The width of the bits (in bits) we want to extract
   * @param _offset The offset of the bits (in bits) we want to extract
   * @return An integer containing _width bits of _value starting at the
   *         _offset bit
   */
  function bits(
    uint256 _value,
    uint256 _width,
    uint256 _offset
  ) internal pure returns (uint256) {
    return (_value / (2**_offset)) & (((2**_width)) - 1);
  }

  function sin_table_lookup(uint256 index) internal pure returns (uint16) {
    bytes memory table = sin_table;
    uint256 offset = (index + 1) * entry_bytes;
    uint16 trigint_value;
    assembly {
      trigint_value := mload(add(table, offset))
    }

    return trigint_value;
  }

  /**
   * Return the sine of an integer approximated angle as a signed 16-bit
   * integer.
   *
   * @param _angle A 14-bit angle. This divides the circle into 16384
   *               angle units, instead of the standard 360 degrees.
   * @return The sine result as a number in the range -32767 to 32767, which maps a range of -1 to 1
   */
  function sin(uint256 _angle) public pure returns (int256) {
    _angle = _angle % ANGLES_IN_CYCLE;
    uint256 interp = bits(_angle, INTERP_WIDTH, INTERP_OFFSET);
    uint256 index = bits(_angle, INDEX_WIDTH, INDEX_OFFSET);

    bool is_odd_quadrant = (_angle & QUADRANT_LOW_MASK) == 0;
    bool is_negative_quadrant = (_angle & QUADRANT_HIGH_MASK) != 0;

    if (!is_odd_quadrant) {
      index = SINE_TABLE_SIZE - 1 - index;
    }

    uint256 x1 = sin_table_lookup(index);
    uint256 x2 = sin_table_lookup(index + 1);
    uint256 approximation = ((x2 - x1) * interp) / (2**INTERP_WIDTH);

    int256 sine;
    if (is_odd_quadrant) {
      sine = int256(x1) + int256(approximation);
    } else {
      sine = int256(x2) - int256(approximation);
    }

    if (is_negative_quadrant) {
      sine *= -1;
    }

    return sine;
  }

  /**
   * Return the cos of an integer approximated angle.
   * It functions just like the sin() method but uses the trigonometric
   * identity sin(x + pi/2) = cos(x) to quickly calculate the cos.
   */
  function cos(uint256 _angle) public pure returns (int256) {
    _angle = (_angle + QUADRANT_LOW_MASK) % ANGLES_IN_CYCLE;
    return sin(_angle);
  }
}
